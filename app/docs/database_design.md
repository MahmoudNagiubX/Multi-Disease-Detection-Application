# Multi Disease Detection System – Database Design

This document describes the **SQLite database structure** for the project:
- What tables we have.
- What each column means.
- Which Python classes/services use each table.
- Where the actual database file lives.

The main database file will be:

- `instance/app.db`

All access to this database will go through:

- `DatabaseManager` (`app/core/managers/database_manager.py`)

---

## 1. `users` Table – User Accounts & Authentication

**Purpose:**  
Stores information about each registered user.  
This table is used for login, registration, and account-related operations.

**Backed by:**
- Python model: `User` (`app/models/user/user.py`)
- Service: `AuthService` (`app/services/authentication/auth_service.py`)
- DB manager: `DatabaseManager` (`app/core/managers/database_manager.py`)

**Columns:**

1. `id`
   - Type: integer
   - Primary Key, auto-increment
   - Unique ID for each user.

2. `username`
   - Type: text
   - Must be unique.
   - Human-readable name used to log in or display in the UI.

3. `email`
   - Type: text
   - Must be unique.
   - Used for login and potential password reset in the future.

4. `password_hash`
   - Type: text
   - Stores the **hashed password**, never the raw (plain) password.
   - The hashing logic is encapsulated inside the `User` class methods
     (for example: `set_password()` and `check_password()`).

5. `created_at`
   - Type: text/datetime (stored as ISO string)
   - Date and time when the user account was created.

6. `updated_at` (optional)
   - Type: text/datetime
   - Date and time when the user information was last updated.

7. `is_active` (optional)
   - Type: integer (0 or 1)
   - Indicates whether the user account is active.

**Usage Flow (conceptual):**

- **Registration:**
  - `AuthService` checks if `username` or `email` already exist in `users`.
  - If not, it creates a `User` object, hashes the password, and inserts a new row.

- **Login:**
  - `AuthService` fetches a row from `users` by username or email.
  - Wraps that row into a `User` instance.
  - Uses the `User`’s `check_password()` method to verify credentials.

---

## 2. `prediction_logs` Table – History of Model Predictions

**Purpose:**  
Stores a **history of predictions** generated by the heart disease and brain tumor models.  
This is useful for:
- Debugging,
- Auditing,
- (Optionally) showing a prediction history to the user later.

**Backed by:**
- (Optional) Python model: `PredictionLog` (if we decide to create it later).
- Service: `PredictionService` (`app/services/prediction/prediction_service.py`)
- DB manager: `DatabaseManager`.

**Columns:**

1. `id`
   - Type: integer
   - Primary Key, auto-increment.

2. `user_id`
   - Type: integer
   - References `users.id`.
   - Identifies which user requested this prediction.

3. `model_type`
   - Type: text
   - Describes which model was used, for example:
     - `"heart_disease"`
     - `"brain_tumor"`

4. `input_summary`
   - Type: text
   - A short summary of the input used for prediction.
   - Examples:
     - For heart disease: `"age=55, sex=1, chol=240, trestbps=140"`.
     - For brain tumor: `"uploaded file: brain_mri_123.png"`.
   - This is meant to be a **compact**, not necessarily full, representation of the inputs.

5. `prediction_result`
   - Type: text
   - Human-readable prediction result:
     - `"High risk"`
     - `"No tumor detected"`
     - `"Glioma detected"`
     - etc.

6. `probability`
   - Type: real/float
   - Confidence score of the prediction (typically between 0.0 and 1.0).

7. `created_at`
   - Type: text/datetime
   - Date and time when the prediction was made.

**Usage Flow (conceptual):**

- User submits data on `/heart-disease` or `/brain-tumor`.
- `routes.py` calls `PredictionService`.
- `PredictionService`:
  - Gets the correct model via `ModelManager`.
  - Calls the model’s `predict()` method.
  - Receives prediction + probability.
  - Inserts a new row into `prediction_logs` with user_id, model_type, summary, result, and probability.

---

## 3. `chat_logs` Table – AI Doctor Chat History (Optional but Professional)

**Purpose:**  
Stores the message history between the user and the AI doctor chatbot.  
This can be used to:
- Maintain conversational context.
- Show recent chat history in the UI.
- Analyze how the chatbot is used.

**Backed by:**
- Service: `ChatbotService` (`app/services/chatbot/chatbot_service.py`)
- DB manager: `DatabaseManager`.

**Columns:**

1. `id`
   - Type: integer
   - Primary Key, auto-increment.

2. `user_id`
   - Type: integer
   - References `users.id`.
   - Identifies which user the message belongs to.

3. `role`
   - Type: text
   - Indicates who sent the message:
     - `"user"` – the human user.
     - `"assistant"` – the AI doctor chatbot.

4. `message`
   - Type: text
   - The full text content of the message.

5. `created_at`
   - Type: text/datetime
   - Date and time when the message was sent.

**Usage Flow (conceptual):**

- On `/chatbot`:
  - User sends a message.
  - Route calls `ChatbotService.send_message(user_message)`.
  - `ChatbotService`:
    - Logs the user’s message into `chat_logs` (role=`"user"`).
    - Sends message to the external chatbot API.
    - Gets the reply.
    - Logs the AI reply into `chat_logs` (role=`"assistant"`).
  - Route sends the AI’s reply back to the browser.

---

## 4. Database File Location and Access Pattern

- The main SQLite database file will be:
  - `instance/app.db`

- **All** database interactions (queries, inserts, updates) go through:

  - `DatabaseManager` (`app/core/managers/database_manager.py`)

**Responsibilities of `DatabaseManager` (conceptual):**

- Know where `app.db` is located.
- Open connections to SQLite.
- Provide helper methods like:
  - `execute(query, params)` → for INSERT/UPDATE/DELETE.
  - `fetch_one(query, params)` → for SELECT that returns a single row.
  - `fetch_all(query, params)` → for SELECT that returns multiple rows.
- Hide raw SQL details from services (`AuthService`, `PredictionService`, `ChatbotService`).

This keeps the design **clean and encapsulated**:
- Services focus on business logic.
- Models represent data structures.
- `DatabaseManager` focuses on talking to SQLite.

users
-----
id (PK)
username (UNIQUE)
email (UNIQUE)
password_hash
created_at
updated_at
is_active


prediction_logs
---------------
id (PK)
user_id (FK → users.id)
model_type
input_summary
prediction_result
probability
created_at


chat_logs
---------
id (PK)
user_id (FK → users.id)
role
message
created_at
